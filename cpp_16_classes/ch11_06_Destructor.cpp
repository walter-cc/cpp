/*
	新增編譯和執行步驟 :
	g++ hello.cpp -o hello
	./hello
===============================
# 此範例可以看到 :

在離開程式區塊前，會自動呼叫解構子	
===============================
# 建構子(constructor)是一種「初始化」class物件的成員函數，可用於將物件內部的「私有資料成員」設定初始值。

# 解構子(Destructor)可作為物件生命周期結束時，用來釋放class所占用的記憶體，讓其他class使用。

# 當物件被建立時，會於constructor內動態配置若干記憶體，當程式結束或物件結束後並不會被自動釋放，所用destructor來釋放。

# 因為建構子也是一種「公用成員函數」，當然可以使用「範圍解析運算子(::)」來將建構子內的程式主體至於class之外。


# 建構子的四個特性 :
  
  1) 建構子名稱 = class名稱， 如 class名稱為 Student = 建構子名稱 Student
  
  2) 沒有回傳值，所以不須指定回傳型態。
  
  3) 當物件被建立時自動產生預設建構子，預設建構子並不提供參數列傳入。
  
  4) 建構子可以有多載功能，也就是一個類別內可以存在多個相同的名稱，但參數列不同的建構子。
  
  
# 解構子的四個特性 :
  
  1) 解構子不可以多載(overlaod)，一個class只有一個解構子。
  
  2) 解構子的第一個字必須是 「~」，其餘和class的名稱相同。
  
  3) 解構子不含任何「參數」和「回傳值」。
  
  4) 當物件的生命週期結束時，或是我們以「delete」將「new」配置的物件釋放時，編譯器就會自動呼叫解構子。在程式區塊結束前，所有在區塊中曾經宣告的物件，都會依照「先建構者後解構」的順序執行。  
  

# C++ 也支援「動態記憶體管理」，因此除了一般的物件建立方式，可以使用「new」和「delete」指令來做指標物件建立與釋放的工作。
  
*/

#include <iostream>	// 引入標準程式庫中相關的輸入、輸出程式
#include <cstdlib>
using namespace std; // std 為標準程式庫的命名空間

class testN			//宣告類別
{
private:				//私用資料成員
	int no[20];	
	int i;
	
public:					//公用資料成員
	testN()			//宣告預設建構子(constructor)
	{
		int i;
		for(i = 0; i < 10; i++)
		{
			no[i] = i;
		}
		cout << "建構子執行完成" << endl ;
	}
	
	~testN()			//宣告解構子(destructor)
	{
		cout << "解構子被呼叫，顯示陣列內容" << endl ;
		int i;
		for(i = 0; i < 10; i++)
		{
			cout << no[i] << "" ;
		}
		cout << "解構子執行完成" << endl ;
	}
	
};						// 記得加上 ";"		#### 重要

int show_result()
{
	testN test1;	//物件離開程式區塊前，會自動呼叫解構子
	return 0;
}
	
int main(void) {
	
	show_result();

	
	return 0;
}





